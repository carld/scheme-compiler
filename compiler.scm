(define *label-num* 0)
(define (gen opcode . args)
  (list (cons opcode args)))
(define (seq . code)
  (apply append code))
(define (gen-label)
  (set! *label-num* (+ 1 *label-num*))
  (string->symbol (format "L_~a" *label-num*)))
(define (gen-var var env)
  (let ((p (in-env-p var env)))
    (if p
        (gen 'LVAR (car p) (second p))
        (gen 'GVAR var))))
(define (gen-set var env)
  (let ((p (in-env-p var env)))
    (if p
        (gen 'LSET (car p) (second p))
        (gen 'GSET var))))
(define (comp-lambda args body env)
  (seq
     (if (> (length args) 0)
         (gen 'ARGS (length args))
         '())
     (comp-begin body (cons args env))
     (gen 'ret)))
(define (fn-p x)
  (eq? 'fn (car x)))
(define (compiler x)
  (set! *label-num* 0)
  (seq
   (gen "global _scheme_entry")
   (gen "section .text")
   (gen "_scheme_entry:")
   (comp-lambda '() x '() )))
(define (comp-begin exps env)
  (cond ((null? exps) '())
        ((= 1 (length exps)) (comp (car exps) env))
        (else (seq (comp (car exps) env)
                   (comp-begin (cdr exps) env)))))
(define (comp-if pred then else env)
  (let ((l1 (gen-label))
        (l2 (gen-label)))
    (seq (comp pred env)
         (gen 'cmp 'al 0)
         (gen 'je l1)
         (comp then env)
         (gen 'jmp l2)
         (list l1)
         (comp else env)
         (list l2))))
(define (comp x env)
  "Compile the expression into a list of instructions"
  (cond
   ((integer? x) (gen 'mov 'rax x))
   ((symbol? x)  (gen-var x env))
                                        ; TODO macros
   ((case (car x)
      (quote (gen 'mov 'rax (cadr x)))
      (if    (comp-if (cadr x) (caddr x) (cadddr x) env))
      (else   (apply gen (car x) (cdr x) ))
      ;; (begin (comp-begin (cdr x) env))
      ;; (set!  (seq (comp (third x) env) (gen-set (second x) env)))
      ;; (if    (comp-if (second x) (third x) (fourth x) env))
      ;; (lambda (gen 'FN (comp-lambda (second x) (cdr (cdr x)) env)))
                                        ;
      ;; (else  (seq (mappend (lambda (y) (comp y env)) (cdr x))
      ;;             (comp (car x) env)
      ;;             (gen 'CALL (length (cdr x)))))

      ))
   (else '() )
   ))
(define (emit asm)
  (cond
   ((string? asm) (format #t "~a ~%" asm))
   ((symbol? asm) (format #t "~a: ~%" asm))
   ((pair? asm)
    (begin
      (format #t "~a" (car asm))
      (if (> (length (cdr asm)) 1)
          (format #t "~{ ~a, ~a ~}" (cdr asm)  )
          (format #t "~{ ~a ~}" (cdr asm)))
      (format #t "~%")))))

(define (emit-program asm-list)
  (for-each emit asm-list))
